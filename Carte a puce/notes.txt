Communication process:
Echanges: se fait en 3 fois
--> envoie 1 apdu de cmd au bidule qui renvoie un apdu de réponse qui contient 2 mots de status sur 2 octets (systématiquement). 0x90 et 0x00 si tout se passe bien.

Y'a des contraintes:
APDU de cmd: 
- partie obligatoire (4 octets)
	CLA (classe): utilisé pour éviter les erreurs --> code qui montre à quoi correspontd ce qu'est lenvoyeur de l'APDU de cmd 
	INS (instruction): on demande à la carte de faire qu'une seul instruction par apdu de cmd. 256 possibilités (8 octets) de combinaisons avec le paramètres 1 et le param 2.
- partire optionnel:
	Data: champ qui sera précédé de sa taille (Lc qui fait 1 octet). On a un env où les octets sont signé (donc de -126 à 127) --> mais on peut changer l'algo de sorte à tout 
	mettre en > 0
Rq: quand y'a pas de data, y'a pas de Lc
	Le: Indique la taille des données qu'on attend en retour. Si on met 0x00 ça indique qu'on ne connait pas la taille pour les données de retour. Donc si on retire le champ le, la carte ne renverra pas des données ou bien ça sera drop.
	
APDU de réponse:
- partie optionelle:
	Data
- partie obligatoire:
	sw1:
	sw2:
Rq: APDU marche avec ou sans contact (donc pas que du NFC)
Rq: le NFC(= nom commercial) c'est de la carte à puce sans contact.

Micromodule components: voir slide
- I/O controller: manage the flow of data between the dcard and card acceptance
- ROM: where the instructions are permanently burned into memory by the silicon manufacturer.
- RAM: temporary storage of results from calculations or I/O communications
- APplication memory: EEPROM stores for 10 years +
rq: plus on écrit dessus, plus on l'abime car électriquemetn parlant quand on écrit dans de la mémoire flash on fragilise le bail.

What is the COS ?
COS: Chip Operating System.
Ajd, une carte c'est un carte java et la partie OS est totalement masqué.
Rq: chaque fabricquant a son OS --> Y'en a avec des cmd générique et d'autres plus précises qui répondent à des demandes particulières.
rq: les contraintes de vie de la carte font que y'aura le cycle de vie à gérer.

En vrai c'est quelques dizaines de Kilos de données une carte on peut pas stocker + dedans en général.

Rq: dans les cartes y'a pas d'OS standards, c'ests ouvent des OS maison.

Barriers to Acceptance of Smart Cards:
- une carte a puce ça sera tjrs + chere qu'une carte à piste magnétique. 
- problème d'interopérabilités entre les programmes (si on a un usage et bah on a un protocole spécifique à cet usage)
ce que chat dit: Voici quelques-uns des problèmes généraux qui pourraient être pertinents pour les smart cards aujourd'hui :

    Sécurité : Les cartes à puce stockent souvent des informations sensibles, telles que des clés cryptographiques, des données d'identification, etc. Les problèmes de sécurité peuvent survenir en raison de vulnérabilités logicielles, d'attaques par force brute, d'interceptions de communication, etc.

    Compatibilité : Certains problèmes peuvent survenir en raison de la diversité des normes et des spécifications dans le domaine des cartes à puce. Assurer une compatibilité entre différentes cartes et lecteurs peut parfois être un défi.

    Évolution technologique : Les avancées constantes dans la technologie des cartes à puce peuvent poser des défis en matière de mise à niveau des infrastructures existantes. La migration vers de nouvelles normes et technologies peut être un processus complexe.

    Applications obsolètes : Certaines applications sur les cartes à puce peuvent devenir obsolètes en raison de l'évolution des besoins et des exigences. La gestion efficace de la transition vers de nouvelles applications est un aspect important.

    Gestion des droits d'accès : La gestion des droits d'accès aux données stockées sur une carte à puce peut poser des problèmes liés à la confidentialité et à la sécurité.

    Intégration avec d'autres technologies : Les cartes à puce sont souvent utilisées en conjonction avec d'autres technologies, telles que les technologies sans fil (NFC, RFID). Des problèmes peuvent survenir lors de l'intégration de ces différentes technologies.

Application areas:
- University identification (variety of apps)
- Health card (containing insurance data)
- retail and loyalty (card marketed to specific consumer profiles)
- ...

Java card open platform (permet de donner une sorte de norme pour spécifier comment faire les échanges de clés crypto par exemple).
Rq: tpm c'est un micro noyau qui est fondu dans une carte mère.

Y'a de l'implémentation off card et on card.

Pratique:
Java card est un sous ensemble de la toute première version sortie de java:
Rq: on peut compiler du java sans avoir un sdk. Avec les scripts qui sont fourni dans le zip c'(est suffisa,t
- scriptwin32: les scripts. Y'a un setenv.bat qui sera le seul à modifier, on devra changer la 1ere ligne sachant que le nom de la var d'env est dans le sous réportoire de src.
- src

tjrs 2 sous repertoir:
- applet: qui va sexécuter dans l'hôte ?
	une applet java card doit etre packagé (package applet), il doit importer tt ce qui est dans javacard.framework avec import javacard.framework
	Il faut un classe qui hérite d'Applet.
	Un constructeur dans lequell on n'y passe qu'une seul fois
	La méthode install est appelé une seule fois dans la carte au niveau de l'initialisation.
	f° process qui va s'appeler a chaque fois que la carte recoit un APDU de cmd.
	Attention;: pas de garbage collector --> donc la mémoire au fur et à mesure qu'on l'utilise, elle n'est pas libérée en java card. 
	--> Donc les strcturtes mém dont on aura besoin seront implémenté dans le constructeur où on construit les taleaux où on fige la taille des tableaux ou des objets qui seront
	nécessaire pour la vie de la carte.
	Comment on se connecte à un Applet ? au début on parle au SM (Security Manager). Imagiez la carte comme un immeuble avec un gardien qui connait tout le monde. Et moi jarive je veux parler à mr machin. Il est censé y avoir un lien entre le gardien et mr machin. Ce lien se fait via this.register() dans le constructeur. 
	Rq: les applets n'ont pas le meme espace d'addressage. Un applet a accès à TOUTE la RAM à un instant t mais y'a que elle qui a accès;
- client: 
	dans le code ce qui est intéressant c'est là où on forge son APDU de cmd:
	"byte [] cmd_ = {0,0,0,0} //;
	CommandAPDU cmd = new CommandAPDU(cmd_)"
	rq: DISPLAY par défaut c'est un booléen qui est à vrai -6> si c'est vrai ça affiche les échanges quand tout s'est bien passé.

On exécute dans l'ordre les script win32 --> Ca cré un dossier out où y'a mini par ex pour le 1er script avec un dossier applet et applet.cap ainsi que script.scr (avec ts les APDUS nécessaire à l'initiation du simulateur);
Attention faut commenter la lignes quand on a pas de lecteur.
script3: on laisse la fenetre ouverte et on lance le 4
script4 : on lance et si tt se passe bien les 2 shell se refemrent et le simulateur est prêt ) etre utilisé
script5: on exécute le simulateur
script6: on exécute le client.

Attention >> Il prend la carte plutot que le simulateur si on a une carte déjà d'insérer !!!!
rq: quand on insère une carte dans un lecteur elle nous crache une suite binaire qui peut etre pris comme un n° de série (ou ATR) et si on va sur le site de ""
, On peutretrouver le constructeur, l'année et dautres infos.

- 1er echange: le gestionnaire de sécurité répond la 1ere fois quand on exécute le cilient et on voit le n° de l'applet (écrit en dure au moment de la compilation) avec lequel le client veut discuter.
- 2eme echange APDU se fait avec cette applet --> et le 90 00 c'est ce que l'applet nous renvoie et non pas le gestionnaire de sécu comme le 1ere echange.

Vocabulaire non compris:
- form factor
- standard PCSC
- 
- 
- 
- 
- 
- 
